{% extends "layout.html" %}
{% block title %}Preview — {{ camera_id }}{% endblock %}

{% block content %}
<h1 class="mb-3">Preview — {{ camera_id }}</h1>

<div class="mb-3 d-flex flex-wrap align-items-center gap-2">
  <button id="btnStart" class="btn btn-primary">Enable Preview</button>
  <button id="btnStop" class="btn btn-outline-secondary">Exit Preview</button>

  <div class="ms-auto d-flex align-items-center gap-2">
    <label class="form-label m-0 small text-muted">ROI [x,y,w,h]</label>
    <input id="roiInput" class="form-control form-control-sm" style="width:260px" placeholder="[0.30, 0.30, 0.40, 0.40]">
    <button id="btnSaveRoi" class="btn btn-sm btn-outline-primary">Save ROI</button>
    <button id="btnPushNode" class="btn btn-sm btn-outline-success">Push to Node</button>
    <button id="btnRestartNode" class="btn btn-sm btn-outline-warning">Restart Node</button>
  </div>
</div>
<div class="form-text mb-3">
  Drag or resize the blue ROI overlay directly on the video. Click <b>Save ROI</b> to store at the hub, then <b>Push to Node</b> to write & restart the node.
</div>

<!-- Stream with ROI overlay -->
<div id="previewWrap" class="ratio ratio-16x9 border rounded bg-light position-relative">
  <!-- MJPEG stream -->
  <img id="stream" alt="preview stream"
       style="display:none; object-fit:contain; width:100%; height:100%;">

  <!-- ROI overlay (absolute in ratio box) -->
  <div id="roiOverlay"
       style="display:none; position:absolute; border:2px dashed #0d6efd; background:rgba(13,110,253,0.15); cursor:move;">
    <!-- resize handles -->
    <div class="roi-handle" data-dir="nw"></div>
    <div class="roi-handle" data-dir="n"></div>
    <div class="roi-handle" data-dir="ne"></div>
    <div class="roi-handle" data-dir="e"></div>
    <div class="roi-handle" data-dir="se"></div>
    <div class="roi-handle" data-dir="s"></div>
    <div class="roi-handle" data-dir="sw"></div>
    <div class="roi-handle" data-dir="w"></div>
  </div>

  <!-- Placeholder when not streaming -->
  <div id="nostream"
       class="text-muted d-flex align-items-center justify-content-center"
       style="position:absolute; inset:0;">
    Preview not running
  </div>
</div>

<!-- Sensor panel -->
<div class="mt-3">
  <div class="card">
    <div class="card-body d-flex flex-wrap align-items-center gap-3">
      <div>
        <div class="text-muted small">Distance</div>
        <div id="distVal" class="fs-4">— mm</div>
      </div>
      <div>
        <div class="text-muted small">Threshold</div>
        <div id="threshVal" class="fs-5">— mm</div>
      </div>
      <div class="ms-auto">
        <span id="triggerBadge" class="badge rounded-pill bg-secondary">No data</span>
      </div>
      <div class="w-100"></div>
      <div class="w-100">
        <div class="text-muted small mb-1">Distance vs. Threshold</div>
        <div class="progress" style="height:8px;">
          <div id="distBar" class="progress-bar" role="progressbar" style="width:0%;" aria-valuemin="0" aria-valuemax="100"></div>
        </div>
        <div class="d-flex justify-content-between small text-muted mt-1">
          <span>Closer</span><span>Farther</span>
        </div>
      </div>
    </div>
  </div>
  <div class="form-text mt-1">Live sensor reads from the node (VL53L0X). Updates ~2×/second.</div>
</div>

<style>
  /* resize handles on the ROI box */
  #roiOverlay .roi-handle {
    position:absolute;
    width:12px; height:12px;
    background:#0d6efd; opacity:0.9;
    border-radius:2px;
    box-shadow:0 0 0 2px #fff;
    cursor:grab;
  }
  #roiOverlay .roi-handle[data-dir="n"]  { left:50%; top:-6px;   transform:translateX(-50%); cursor:ns-resize; }
  #roiOverlay .roi-handle[data-dir="s"]  { left:50%; bottom:-6px; transform:translateX(-50%); cursor:ns-resize; }
  #roiOverlay .roi-handle[data-dir="e"]  { right:-6px; top:50%;   transform:translateY(-50%); cursor:ew-resize; }
  #roiOverlay .roi-handle[data-dir="w"]  { left:-6px; top:50%;    transform:translateY(-50%); cursor:ew-resize; }
  #roiOverlay .roi-handle[data-dir="nw"] { left:-6px; top:-6px;   cursor:nwse-resize; }
  #roiOverlay .roi-handle[data-dir="ne"] { right:-6px; top:-6px;  cursor:nesw-resize; }
  #roiOverlay .roi-handle[data-dir="se"] { right:-6px; bottom:-6px; cursor:nwse-resize; }
  #roiOverlay .roi-handle[data-dir="sw"] { left:-6px; bottom:-6px;  cursor:nesw-resize; }
</style>

<script>
const camId = {{ camera_id|tojson }};
const host  = {{ (endpoint.ssh_host or '')|tojson }};
const roiFromDb = {{ (af_roi_norm or none)|tojson }};

// ---------- generic helpers ----------
async function postJSON(url, body) {
  const res = await fetch(url, {method:"POST", headers:{"Content-Type":"application/json"}, body: JSON.stringify(body||{})});
  let data = {};
  try { data = await res.json(); } catch (_) {}
  if (!res.ok || (data && data.ok === false)) {
    throw new Error((data && (data.error||data.raw)) || res.statusText);
  }
  return data;
}
function clamp01(x){ x = parseFloat(x); return isFinite(x) ? Math.min(1, Math.max(0, x)) : 0; }
function sanitizeROI(arr) {
  if (!Array.isArray(arr) || arr.length !== 4) return null;
  let [x,y,w,h] = arr.map(clamp01);
  w = Math.min(w, 1 - x);
  h = Math.min(h, 1 - y);
  return [x,y,w,h];
}
function getROI() {
  try {
    const v = JSON.parse(document.getElementById("roiInput").value);
    return sanitizeROI(v);
  } catch { return null; }
}
function setROI(arr) {
  const v = sanitizeROI(arr) || [0.3,0.3,0.4,0.4];
  document.getElementById("roiInput").value = JSON.stringify(v);
  drawOverlay(); // refresh
}

// ---------- displayed image geometry ----------
function getDisplayBox() {
  const wrap = document.getElementById('previewWrap');
  const img  = document.getElementById('stream');
  const cw = wrap.clientWidth, ch = wrap.clientHeight;

  // Natural image size (fallback to 1920x1080 until the first frame reports)
  const iw = img.naturalWidth  || 1920;
  const ih = img.naturalHeight || 1080;
  const ar = iw / ih, car = cw / ch;

  let dw, dh, offX = 0, offY = 0;
  if (ar > car) { // limited by width
    dw = cw; dh = Math.round(cw / ar);
    offY = Math.round((ch - dh) / 2);
  } else {       // limited by height
    dh = ch; dw = Math.round(ch * ar);
    offX = Math.round((cw - dw) / 2);
  }
  return {offX, offY, dw, dh, cw, ch};
}

// ---------- stream control ----------
let sensorTimer = null;
let overlayTimer = null;

async function startPreview() {
  await postJSON('/action/secure/preview/start', {camera_id: camId});
  const img = document.getElementById('stream');
  img.src = `http://${host}:8080/api/live/mjpeg?ts=${Date.now()}`;
  img.onload = () => { showStream(true); drawOverlay(); };
  showStream(true);
  startSensorPolling();
  startOverlayPolling();
}
async function stopPreview() {
  stopSensorPolling();
  stopOverlayPolling();
  try { await postJSON('/action/secure/preview/stop', {camera_id: camId}); } catch(e){}
  const img = document.getElementById('stream');
  img.removeAttribute('src');
  showStream(false);
}
function showStream(on) {
  const img = document.getElementById('stream');
  const ns  = document.getElementById('nostream');
  const ov  = document.getElementById('roiOverlay');
  if (on) {
    img.style.display = '';
    ns.style.display = 'none';
    ov.style.display = '';
  } else {
    img.style.display = 'none';
    ns.style.display = '';
    ov.style.display = 'none';
  }
}

// ---------- overlay render ----------
function drawOverlay() {
  const img = document.getElementById('stream');
  const ov  = document.getElementById('roiOverlay');
  if (img.style.display === 'none') return;

  const roi = getROI();
  if (!roi) return;

  const {offX, offY, dw, dh} = getDisplayBox();
  const [nx, ny, nw, nh] = roi;

  const x = Math.round(offX + nx * dw);
  const y = Math.round(offY + ny * dh);
  const w = Math.round(nw * dw);
  const h = Math.round(nh * dh);

  ov.style.left   = x + 'px';
  ov.style.top    = y + 'px';
  ov.style.width  = w + 'px';
  ov.style.height = h + 'px';
}

function startOverlayPolling() {
  if (overlayTimer) clearInterval(overlayTimer);
  overlayTimer = setInterval(drawOverlay, 300);
  window.addEventListener('resize', drawOverlay);
}
function stopOverlayPolling() {
  if (overlayTimer) clearInterval(overlayTimer);
  overlayTimer = null;
  window.removeEventListener('resize', drawOverlay);
}

// ---------- overlay interaction (drag + resize) ----------
(() => {
  const ov = document.getElementById('roiOverlay');
  const wrap = document.getElementById('previewWrap');

  let dragging = false;
  let mode = null;      // "move" or "resize"
  let dir = null;       // for resize: n/e/s/w/ne/nw/se/sw
  let startPx = {x:0,y:0};
  let startROI = [0,0,0,0];

  function pxToNorm(dx, dy, geom) {
    // convert pixel deltas to normalized deltas in ROI space
    return [dx / geom.dw, dy / geom.dh];
  }

  function clampRoi([x,y,w,h]) {
    x = Math.max(0, Math.min(1, x));
    y = Math.max(0, Math.min(1, y));
    if (x + w > 1) w = 1 - x;
    if (y + h > 1) h = 1 - y;
    w = Math.max(0.001, w);
    h = Math.max(0.001, h);
    return [x,y,w,h];
  }

  function onPointerDown(e) {
    if (document.getElementById('stream').style.display === 'none') return;
    e.preventDefault();
    const handle = e.target.closest('.roi-handle');
    mode = handle ? 'resize' : 'move';
    dir = handle ? (handle.getAttribute('data-dir') || '') : null;
    dragging = true;

    startPx = {x: e.clientX, y: e.clientY};
    startROI = getROI() || [0.3,0.3,0.4,0.4];

    // capture for move events
    document.addEventListener('pointermove', onPointerMove);
    document.addEventListener('pointerup', onPointerUp);
  }

  function onPointerMove(e) {
    if (!dragging) return;
    const geom = getDisplayBox();
    const dxPx = e.clientX - startPx.x;
    const dyPx = e.clientY - startPx.y;
    const [dx, dy] = pxToNorm(dxPx, dyPx, geom);

    let [x,y,w,h] = startROI;

    if (mode === 'move') {
      x += dx; y += dy;
      [x,y,w,h] = clampRoi([x,y,w,h]);
    } else if (mode === 'resize') {
      let nx = x, ny = y, nw = w, nh = h;
      if (dir.includes('w')) { nx = x + dx; nw = w - dx; }
      if (dir.includes('e')) { nw = w + dx; }
      if (dir.includes('n')) { ny = y + dy; nh = h - dy; }
      if (dir.includes('s')) { nh = h + dy; }

      // Prevent flipping
      if (nw < 0) { nx = nx + nw; nw = -nw; }
      if (nh < 0) { ny = ny + nh; nh = -nh; }

      [x,y,w,h] = clampRoi([nx,ny,nw,nh]);
    }

    setROI([x,y,w,h]); // updates input + redraw
  }

  function onPointerUp() {
    dragging = false;
    mode = null; dir = null;
    document.removeEventListener('pointermove', onPointerMove);
    document.removeEventListener('pointerup', onPointerUp);
  }

  // attach
  ov.addEventListener('pointerdown', onPointerDown);
})();

// ---------- sensor polling ----------
function setBadge(state) {
  const el = document.getElementById('triggerBadge');
  if (state === 'trigger') { el.className = 'badge rounded-pill bg-danger'; el.textContent = 'Would trigger'; }
  else if (state === 'no-trigger') { el.className = 'badge rounded-pill bg-success'; el.textContent = 'Clear'; }
  else { el.className = 'badge rounded-pill bg-secondary'; el.textContent = 'No data'; }
}
function updateSensorUI(obj) {
  const dEl = document.getElementById('distVal');
  const tEl = document.getElementById('threshVal');
  const bar = document.getElementById('distBar');

  if (!obj || obj.ok === false) {
    dEl.textContent = '— mm';
    tEl.textContent = '— mm';
    bar.style.width = '0%';
    setBadge('no-data');
    return;
  }

  const dist = obj.distance_mm ?? null;
  const thr  = obj.threshold_mm ?? null;
  const would = !!obj.would_trigger;

  dEl.textContent = (dist !== null) ? `${dist} mm` : '— mm';
  tEl.textContent = (thr  !== null) ? `${thr} mm`  : '— mm';

  let pct = 0;
  if (dist !== null && thr && thr > 0) {
    pct = Math.max(0, Math.min(100, Math.round((dist / (thr*2)) * 100)));
  }
  bar.style.width = pct + '%';
  bar.setAttribute('aria-valuenow', pct);
  bar.className = 'progress-bar ' + (would ? 'bg-danger' : 'bg-success');

  setBadge(would ? 'trigger' : 'no-trigger');
}
async function pollSensorOnce() {
  if (!host) return;
  try {
    const res = await fetch(`http://${host}:8080/api/live/sensor`, {cache:'no-cache'});
    const obj = await res.json().catch(()=> ({}));
    updateSensorUI(obj);
  } catch (e) { updateSensorUI(null); }
}
function startSensorPolling() {
  pollSensorOnce();
  if (sensorTimer) clearInterval(sensorTimer);
  sensorTimer = setInterval(pollSensorOnce, 500);
}
function stopSensorPolling() {
  if (sensorTimer) clearInterval(sensorTimer);
  sensorTimer = null;
}

// ---------- ROI actions ----------
function loadRoiFromDbOrLocal() {
  const key = `roi_${camId}`;
  let v = roiFromDb;
  if (!v) {
    try { v = JSON.parse(localStorage.getItem(key) || 'null'); } catch {}
  }
  setROI(v || [0.30, 0.30, 0.40, 0.40]);
}
function saveRoiToLocal() {
  const v = getROI();
  if (!v) throw new Error("Invalid ROI. Use [x,y,w,h] with 0..1 values.");
  localStorage.setItem(`roi_${camId}`, JSON.stringify(v));
}
async function saveRoiToHub() {
  const v = getROI();
  if (!v) throw new Error("Invalid ROI. Use [x,y,w,h] with 0..1 values.");
  await postJSON('/action/secure/preview/save_roi', {camera_id: camId, roi_norm: v});
}
async function pushToNode() {
  await postJSON('/action/secure/cameras/push', {camera_id: camId});
  alert('Pushed to node and service restarted.');
}
async function restartNode() {
  await postJSON('/action/secure/node/restart', {camera_id: camId});
  alert('Restart requested.');
}

// ---------- wire up buttons ----------
document.getElementById('btnStart').addEventListener('click', async ()=>{
  try { await startPreview(); } catch(e){ alert('Start failed: '+e.message); }
});
document.getElementById('btnStop').addEventListener('click', async ()=>{
  try { await stopPreview(); } catch(e){ alert('Stop failed: '+e.message); }
});
document.getElementById('btnSaveRoi').addEventListener('click', async ()=>{
  try { saveRoiToLocal(); await saveRoiToHub(); alert('ROI saved.'); } catch(e){ alert(e.message); }
});
document.getElementById('btnPushNode').addEventListener('click', async ()=>{
  try { await pushToNode(); } catch(e){ alert('Push failed: '+e.message); }
});
document.getElementById('btnRestartNode').addEventListener('click', async ()=>{
  try { await restartNode(); } catch(e){ alert('Restart failed: '+e.message); }
});
document.getElementById('roiInput').addEventListener('input', drawOverlay);

// init
loadRoiFromDbOrLocal();
</script>
{% endblock %}
